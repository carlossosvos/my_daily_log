import 'package:drift/drift.dart';
import 'package:my_daily_log/data/datasources/local/app_database.dart';
import 'package:my_daily_log/data/datasources/local/tables/daily_log_table.dart';

// This will be generated by drift_dev
part 'daily_log_dao.g.dart';

/// Data Access Object for DailyLogs table
/// Contains all database operations for daily logs
@DriftAccessor(tables: [DailyLogs])
class DailyLogDao extends DatabaseAccessor<AppDatabase>
    with _$DailyLogDaoMixin {
  DailyLogDao(super.db);

  /// Get all daily logs for a specific user
  /// Returns a Future that completes with the list
  Future<List<DailyLog>> getAllLogsByUser(String userId) {
    return (select(dailyLogs)
          ..where((t) => t.userId.equals(userId))
          ..orderBy([(t) => OrderingTerm.desc(t.createdAt)]))
        .get();
  }

  Stream<List<DailyLog>> watchAllLogsByUser(String userId) {
    return (select(dailyLogs)
          ..where((t) => t.userId.equals(userId))
          ..orderBy([(t) => OrderingTerm.desc(t.createdAt)]))
        .watch();
  }

  Future<DailyLog?> getLogById(int id) {
    return (select(dailyLogs)..where((t) => t.id.equals(id))).getSingleOrNull();
  }

  Stream<DailyLog?> watchLogById(int id) {
    return (select(
      dailyLogs,
    )..where((t) => t.id.equals(id))).watchSingleOrNull();
  }

  Future<int> createLog(DailyLogsCompanion log) {
    return into(dailyLogs).insert(log);
  }

  Future<bool> updateLog(DailyLog log) {
    return update(dailyLogs).replace(log);
  }

  Future<int> deleteLog(int id) {
    return (delete(dailyLogs)..where((t) => t.id.equals(id))).go();
  }

  Future<int> deleteAllLogsByUser(String userId) {
    return (delete(dailyLogs)..where((t) => t.userId.equals(userId))).go();
  }

  Future<int> getLogCountByUser(String userId) async {
    final countExp = dailyLogs.id.count();
    final query = selectOnly(dailyLogs)
      ..addColumns([countExp])
      ..where(dailyLogs.userId.equals(userId));

    final result = await query.getSingle();
    return result.read(countExp) ?? 0;
  }

  Future<List<DailyLog>> searchLogs(String userId, String searchTerm) {
    final pattern = '%$searchTerm%';
    return (select(dailyLogs)
          ..where(
            (t) =>
                t.userId.equals(userId) &
                (t.title.like(pattern) | t.content.like(pattern)),
          )
          ..orderBy([(t) => OrderingTerm.desc(t.createdAt)]))
        .get();
  }
}
